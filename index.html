<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dotCARV - CARV Name Service</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåê</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 min-h-screen text-white">
    
    <header class="p-6 border-b border-white/10 backdrop-blur-lg bg-white/5 sticky top-0 z-40">
        <div class="max-w-6xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg flex items-center justify-center font-bold text-xl shadow-lg">C</div>
                <div>
                    <h1 class="text-2xl font-bold">dotCARV</h1>
                    <p class="text-xs text-gray-400">CARV Name Service</p>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div id="networkBadge" class="hidden px-3 py-1 bg-yellow-500/20 text-yellow-300 rounded-full text-sm font-semibold">Testnet</div>
                <button id="connectWallet" class="px-6 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold transition-all shadow-lg">Connect Wallet</button>
            </div>
        </div>
    </header>

    <!-- Wallet Selection Modal -->
    <div id="walletSelectionModal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 max-w-md w-full mx-4">
            <h3 class="text-2xl font-bold mb-6 text-center">Connect Wallet</h3>
            <div class="space-y-3">
                <button onclick="connectSpecificWallet('backpack')" class="w-full px-6 py-4 bg-orange-600 hover:bg-orange-700 rounded-lg font-semibold transition-all flex items-center justify-between">
                    <span>üéí Backpack</span>
                    <span class="text-xs text-orange-200">Recommended</span>
                </button>
                <button onclick="connectSpecificWallet('phantom')" class="w-full px-6 py-4 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold transition-all flex items-center justify-between">
                    <span>üëª Phantom</span>
                    <span class="text-xs text-purple-200">Popular</span>
                </button>
                <button onclick="connectSpecificWallet('solflare')" class="w-full px-6 py-4 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-semibold transition-all flex items-center justify-between">
                    <span>‚òÄÔ∏è Solflare</span>
                    <span class="text-xs text-yellow-200">Mobile</span>
                </button>
                <button onclick="closeWalletSelection()" class="w-full px-6 py-4 bg-white/10 hover:bg-white/20 rounded-lg font-semibold transition-all">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Wallet Menu Dropdown -->
    <div id="walletMenu" class="hidden absolute top-16 right-6 bg-white/10 backdrop-blur-lg rounded-xl border border-white/20 p-4 min-w-[280px] z-50">
        <div class="space-y-3">
            <div class="flex items-center gap-3 pb-3 border-b border-white/10">
                <div class="w-10 h-10 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full"></div>
                <div>
                    <p class="text-sm font-semibold" id="walletAddress">0x123...789</p>
                    <p class="text-xs text-gray-400" id="walletBalance">0 SOL</p>
                </div>
            </div>
            <button onclick="copyAddress()" class="w-full px-4 py-2 bg-white/5 hover:bg-white/10 rounded-lg text-left text-sm transition-all">
                üìã Copy Address
            </button>
            <button onclick="disconnectWallet()" class="w-full px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-300 rounded-lg text-left text-sm transition-all">
                üîå Disconnect
            </button>
        </div>
    </div>

    <!-- Send SOL Modal -->
    <div id="sendSOLModal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 max-w-md w-full mx-4">
            <h3 class="text-2xl font-bold mb-4">üí∏ Send SOL</h3>
            <p class="text-gray-300 mb-2">Send SOL to owner of:</p>
            <p class="text-purple-400 font-bold text-xl mb-4" id="sendToDomain"></p>
            <div class="bg-white/5 rounded-lg p-3 mb-4">
                <p class="text-xs text-gray-400 mb-1">Owner Address:</p>
                <p class="text-sm font-mono break-all" id="sendToAddress">Loading...</p>
            </div>
            <input 
                type="number" 
                id="solAmount" 
                placeholder="Amount in SOL"
                step="0.01"
                class="w-full px-4 py-3 bg-white/10 rounded-lg border border-white/20 focus:border-purple-500 focus:outline-none mb-4"
            />
            <div class="flex gap-3">
                <button onclick="closeSendSOLModal()" class="flex-1 px-4 py-3 bg-white/10 hover:bg-white/20 rounded-lg font-semibold">
                    Cancel
                </button>
                <button onclick="sendSOL()" class="flex-1 px-4 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold">
                    Send
                </button>
            </div>
        </div>
    </div>

    <!-- Send NFT Modal -->
    <div id="sendNFTModal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 max-w-md w-full mx-4">
            <h3 class="text-2xl font-bold mb-4">üé® Send NFT</h3>
            <p class="text-gray-300 mb-2">Send NFT to owner of:</p>
            <p class="text-purple-400 font-bold text-xl mb-4" id="sendNFTToDomain"></p>
            <div class="bg-white/5 rounded-lg p-3 mb-4">
                <p class="text-xs text-gray-400 mb-1">Owner Address:</p>
                <p class="text-sm font-mono break-all" id="sendNFTToAddress">Loading...</p>
            </div>
            <input 
                type="text" 
                id="nftMintAddress" 
                placeholder="NFT Mint Address"
                class="w-full px-4 py-3 bg-white/10 rounded-lg border border-white/20 focus:border-purple-500 focus:outline-none mb-2 font-mono text-sm"
            />
            <p class="text-xs text-gray-400 mb-4">Enter the mint address of the NFT you want to send</p>
            <div class="flex gap-3">
                <button onclick="closeSendNFTModal()" class="flex-1 px-4 py-3 bg-white/10 hover:bg-white/20 rounded-lg font-semibold">
                    Cancel
                </button>
                <button onclick="sendNFT()" class="flex-1 px-4 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold">
                    Send
                </button>
            </div>
        </div>
    </div>

    <main class="max-w-6xl mx-auto px-6 py-12">
        <div class="text-center mb-16">
            <h2 class="text-5xl md:text-6xl font-bold mb-4 bg-gradient-to-r from-purple-400 via-pink-400 to-blue-400 bg-clip-text text-transparent">Your Web3 Identity</h2>
            <p class="text-xl md:text-2xl text-gray-300 mb-8">Claim your .carv domain for just <span class="text-purple-400 font-bold">0.02 SOL/year</span></p>
        </div>

        <div class="bg-white/5 backdrop-blur-lg rounded-2xl p-8 mb-8 border border-white/10 shadow-2xl">
            <h3 class="text-2xl font-bold mb-6">Search Domain</h3>
            <div class="flex flex-col md:flex-row gap-4 mb-4">
                <div class="flex-1">
                    <div class="relative">
                        <input type="text" id="domainInput" placeholder="yourname" class="w-full px-6 py-4 bg-white/10 rounded-lg border border-white/20 focus:border-purple-500 focus:outline-none text-lg pr-20" maxlength="32"/>
                        <span class="absolute right-6 top-1/2 -translate-y-1/2 text-gray-400 font-semibold text-lg">.carv</span>
                    </div>
                    <p class="text-sm text-gray-400 mt-2">3-32 characters ‚Ä¢ Lowercase letters, numbers, and hyphens only</p>
                </div>
                <button id="searchBtn" class="px-8 py-4 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold transition-all shadow-lg whitespace-nowrap">Search</button>
            </div>
            <div id="domainStatus" class="hidden mt-6 p-6 rounded-lg border"></div>
            <div id="domainOwnerInfo" class="hidden mt-6 p-6 rounded-lg border border-blue-500 bg-blue-500/10"></div>
            <div id="registerForm" class="hidden mt-6 space-y-4">
                <div>
                    <label class="block text-sm font-semibold mb-2">Metadata (Optional)</label>
                    <textarea id="metadataInput" placeholder='{"twitter": "@handle"}' class="w-full px-4 py-3 bg-white/10 rounded-lg border border-white/20 focus:border-purple-500 focus:outline-none font-mono text-sm" rows="3"></textarea>
                </div>
                <button id="registerBtn" class="w-full px-6 py-4 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 rounded-lg font-bold text-lg transition-all shadow-lg">Register for 0.02 SOL/year</button>
            </div>
        </div>

        <div class="bg-white/5 backdrop-blur-lg rounded-2xl p-8 border border-white/10 shadow-2xl">
            <h3 class="text-2xl font-bold mb-6">My Domains</h3>
            <div id="myDomains" class="space-y-4">
                <div class="text-gray-400 text-center py-12"><p>Connect your wallet to see your domains</p></div>
            </div>
        </div>
    </main>

    <div id="loadingOverlay" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 text-center">
            <div class="w-16 h-16 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <p class="text-xl font-semibold mb-2" id="loadingText">Processing...</p>
            <p class="text-sm text-gray-400" id="loadingSubtext">Please wait...</p>
        </div>
    </div>

    <div id="toast" class="hidden fixed top-6 right-6 bg-white/10 backdrop-blur-lg rounded-lg p-4 border border-white/20 z-50 min-w-[300px] shadow-2xl">
        <div class="flex items-start gap-3">
            <div id="toastIcon" class="w-6 h-6 flex-shrink-0"></div>
            <div class="flex-1"><p id="toastMessage" class="text-sm"></p></div>
            <button id="toastClose" class="text-gray-400 hover:text-white">√ó</button>
        </div>
    </div>

    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
    
    <script>
        // BUFFER POLYFILL
        if (typeof Buffer === 'undefined') {
            window.Buffer = {
                from: function(data, encoding) {
                    if (typeof data === 'string') {
                        return new TextEncoder().encode(data);
                    }
                    return data;
                },
                alloc: function(size) {
                    return new Uint8Array(size);
                },
                concat: function(arrays) {
                    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
                    const result = new Uint8Array(totalLength);
                    let offset = 0;
                    for (const arr of arrays) {
                        result.set(arr, offset);
                        offset += arr.length;
                    }
                    return result;
                }
            };
        }
        
        function debugLog(msg, data) {
            console.log(`[CARV] ${msg}`, data || '');
            const el = document.getElementById('debugInfo');
            if (!el) return;
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.innerHTML = `<span class="text-gray-400">[${time}]</span> ${msg}${data ? ': <span class="text-green-400">' + JSON.stringify(data) + '</span>' : ''}`;
            el.appendChild(div);
            el.scrollTop = el.scrollHeight;
        }

        const CONFIG = {
            PROGRAM_ID: "8MPuR7zKVk2XQJ7apb1Ksc49oKF4AozvF5huKhwBubCa",
            TREASURY_ADDRESS: "3KLEMtjay3MTvNvtmBq8FNkgvfmw3phPUuvggP2vPo83",
            NETWORK: "CARV SVM testnet",
            RPC_ENDPOINT: "https://rpc.testnet.carv.io/rpc",
        };

        let wallet = null;
        let connection = null;
        let walletProvider = null; // Store which wallet is being used

        async function init() {
            try {
                debugLog('Starting init...');
                
                if (typeof solanaWeb3 === 'undefined') {
                    debugLog('ERROR: Solana Web3 not loaded!');
                    showToast('Please refresh the page', 'error');
                    return;
                }
                
                debugLog('Solana Web3 loaded');
                
                if (CONFIG.NETWORK.includes("testnet")) {
                    document.getElementById("networkBadge").classList.remove("hidden");
                }
                
                // Check which wallets are available
                const availableWallets = [];
                if (window.backpack) {
                    availableWallets.push('Backpack');
                    debugLog('Backpack detected');
                }
                if (window.solana && window.solana.isPhantom) {
                    availableWallets.push('Phantom');
                    debugLog('Phantom detected');
                }
                if (window.solflare) {
                    availableWallets.push('Solflare');
                    debugLog('Solflare detected');
                }
                
                debugLog('Available wallets', { wallets: availableWallets });
                
                // Auto-connect priority: Backpack > Solflare > Phantom
                // Backpack is recommended for custom RPC
                if (window.backpack?.isConnected) {
                    walletProvider = window.backpack;
                    debugLog('Auto-connecting to Backpack...');
                    await connectWallet();
                } else if (window.solflare?.isConnected) {
                    walletProvider = window.solflare;
                    debugLog('Auto-connecting to Solflare...');
                    await connectWallet();
                } else if (window.solana?.isConnected && !window.solana.isPhantom) {
                    // Other Solana wallets (not Phantom)
                    walletProvider = window.solana;
                    debugLog('Auto-connecting to Solana wallet...');
                    await connectWallet();
                }
                // Note: Phantom auto-connect disabled due to custom RPC compatibility issues
                
                debugLog('Init complete!');
            } catch (e) {
                debugLog('ERROR init', e.message);
                console.error(e);
            }
        }

        function showWalletSelection() {
            document.getElementById('walletSelectionModal').classList.remove('hidden');
        }

        function closeWalletSelection() {
            document.getElementById('walletSelectionModal').classList.add('hidden');
        }

        async function connectSpecificWallet(walletType) {
            try {
                debugLog('Connecting to ' + walletType);
                closeWalletSelection();
                
                if (walletType === 'backpack') {
                    if (!window.backpack) {
                        showToast("Install Backpack wallet!", "error");
                        setTimeout(() => window.open("https://backpack.app/", "_blank"), 2000);
                        return;
                    }
                    walletProvider = window.backpack;
                } else if (walletType === 'phantom') {
                    if (!window.solana || !window.solana.isPhantom) {
                        showToast("Install Phantom wallet!", "error");
                        setTimeout(() => window.open("https://phantom.app/", "_blank"), 2000);
                        return;
                    }
                    walletProvider = window.solana;
                } else if (walletType === 'solflare') {
                    if (!window.solflare) {
                        showToast("Install Solflare wallet!", "error");
                        setTimeout(() => window.open("https://solflare.com/", "_blank"), 2000);
                        return;
                    }
                    walletProvider = window.solflare;
                }
                
                await connectWallet();
            } catch (e) {
                debugLog('ERROR connecting specific wallet', e.message);
                console.error(e);
                showToast("Failed: " + e.message, "error");
            }
        }

        async function connectWallet() {
            try {
                debugLog('Connecting wallet...');
                
                if (!walletProvider) {
                    showToast("No wallet selected!", "error");
                    return;
                }

                showLoading('Connecting...', 'Approve in wallet');
                
                const resp = await walletProvider.connect();
                wallet = resp.publicKey;
                
                const walletName = walletProvider === window.backpack ? 'Backpack' : 
                                   walletProvider === window.solflare ? 'Solflare' : 'Phantom';
                
                debugLog('Wallet connected', { 
                    address: wallet.toString(),
                    provider: walletName
                });
                
                connection = new solanaWeb3.Connection(CONFIG.RPC_ENDPOINT, "confirmed");
                debugLog('RPC connected to ' + CONFIG.RPC_ENDPOINT);
                
                updateUI();
                hideLoading();
                showToast(`Connected to ${walletName}! ‚úÖ`, "success");
                loadMyDomains();
                
            } catch (e) {
                debugLog('ERROR connect', e.message);
                console.error(e);
                hideLoading();
                showToast("Failed: " + e.message, "error");
            }
        }

        async function getDomainPDA(name) {
            try {
                const domainBytes = new TextEncoder().encode("domain");
                const nameBytes = new TextEncoder().encode(name);
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                
                const [pda, bump] = await solanaWeb3.PublicKey.findProgramAddressSync(
                    [domainBytes, nameBytes],
                    programId
                );
                
                return pda;
            } catch (e) {
                debugLog('ERROR getting PDA', e.message);
                throw e;
            }
        }

        async function searchDomain() {
            try {
                const input = document.getElementById("domainInput").value.toLowerCase().trim();
                
                if (!input) {
                    showToast("Enter domain name", "error");
                    return;
                }
                if (input.length < 3 || input.length > 32) {
                    showToast("3-32 characters", "error");
                    return;
                }
                if (!/^[a-z0-9-]+$/.test(input)) {
                    showToast("Letters, numbers, hyphens only", "error");
                    return;
                }

                if (!connection) {
                    showToast("Connect wallet first", "error");
                    return;
                }

                showLoading("Searching...");

                const pda = await getDomainPDA(input);
                const accountInfo = await connection.getAccountInfo(pda);

                const statusDiv = document.getElementById("domainStatus");
                const registerForm = document.getElementById("registerForm");
                const ownerInfoDiv = document.getElementById("domainOwnerInfo");

                if (accountInfo) {
                    const data = accountInfo.data;
                    const ownerBytes = data.slice(8, 40);
                    const owner = new solanaWeb3.PublicKey(ownerBytes);
                    
                    let metadata = '';
                    try {
                        let offset = 40;
                        const nameLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                        offset += 4 + nameLen + 8 + 8 + 1;
                        const dataLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                        offset += 4;
                        const dataBytes = data.slice(offset, offset + dataLen);
                        metadata = new TextDecoder().decode(dataBytes);
                    } catch (e) {}
                    
                    statusDiv.className = "mt-6 p-6 rounded-lg border border-red-500 bg-red-500/10";
                    statusDiv.innerHTML = `<div class="flex items-center gap-3"><svg class="w-6 h-6 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293z" clip-rule="evenodd"/></svg><span class="font-bold text-lg">${input}.carv is taken ‚ùå</span></div>`;
                    statusDiv.classList.remove("hidden");
                    registerForm.classList.add("hidden");
                    
                    const isMyDomain = wallet && owner.toString() === wallet.toString();
                    
                    ownerInfoDiv.className = "mt-6 p-6 rounded-lg border border-blue-500 bg-blue-500/10";
                    ownerInfoDiv.innerHTML = `
                        <div class="mb-4">
                            <p class="text-sm text-gray-400 mb-2">Owner:</p>
                            <p class="font-mono text-sm break-all text-blue-300">${owner.toString()}</p>
                            ${isMyDomain ? '<p class="text-green-400 text-sm mt-2">‚úÖ This is your domain</p>' : ''}
                        </div>
                        ${metadata ? `
                            <div class="mb-4 p-3 bg-white/5 rounded">
                                <p class="text-xs text-gray-400 mb-1 font-semibold">Metadata:</p>
                                <pre class="font-mono text-xs text-gray-300 overflow-x-auto whitespace-pre-wrap">${metadata}</pre>
                            </div>
                        ` : ''}
                        ${!isMyDomain && wallet ? `
                            <div class="flex gap-2 mt-4">
                                <button onclick="showSendSOLModalForSearch('${input}', '${owner.toString()}')" class="flex-1 px-4 py-3 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-semibold transition-all flex items-center justify-center gap-2">
                                    üí∏ Send SOL
                                </button>
                                <button onclick="showSendNFTModalForSearch('${input}', '${owner.toString()}')" class="flex-1 px-4 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-semibold transition-all flex items-center justify-center gap-2">
                                    üé® Send NFT
                                </button>
                            </div>
                        ` : ''}
                        ${!wallet ? '<p class="text-yellow-400 text-sm mt-4">üí° Connect wallet to send SOL or NFT</p>' : ''}
                    `;
                    ownerInfoDiv.classList.remove("hidden");
                } else {
                    statusDiv.className = "mt-6 p-6 rounded-lg border border-green-500 bg-green-500/10";
                    statusDiv.innerHTML = `<div class="flex items-center gap-3"><svg class="w-6 h-6 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg><span class="font-bold text-lg">${input}.carv is available! üéâ</span></div>`;
                    statusDiv.classList.remove("hidden");
                    ownerInfoDiv.classList.add("hidden");
                    
                    if (wallet) {
                        registerForm.classList.remove("hidden");
                    }
                }
                
                hideLoading();
                
            } catch (e) {
                debugLog('ERROR search', e.message);
                hideLoading();
                showToast("Error: " + e.message, "error");
            }
        }

        async function registerDomain() {
            try {
                const name = document.getElementById("domainInput").value.toLowerCase().trim();
                if (!wallet) {
                    showToast("Connect wallet", "error");
                    return;
                }
                
                showLoading("Building transaction...");

                const pda = await getDomainPDA(name);
                const treasury = new solanaWeb3.PublicKey(CONFIG.TREASURY_ADDRESS);
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                
                const discriminator = new Uint8Array([211, 124, 67, 15, 211, 194, 178, 240]);
                const nameBytes = new TextEncoder().encode(name);
                const nameLengthBytes = new Uint8Array(4);
                new DataView(nameLengthBytes.buffer).setUint32(0, nameBytes.length, true);
                
                const instructionData = new Uint8Array(discriminator.length + nameLengthBytes.length + nameBytes.length);
                let offset = 0;
                instructionData.set(discriminator, offset);
                offset += discriminator.length;
                instructionData.set(nameLengthBytes, offset);
                offset += nameLengthBytes.length;
                instructionData.set(nameBytes, offset);
                
                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: pda, isSigner: false, isWritable: true },
                        { pubkey: wallet, isSigner: true, isWritable: true },
                        { pubkey: treasury, isSigner: false, isWritable: true },
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                    ],
                    programId: programId,
                    data: instructionData,
                });
                
                const transaction = new solanaWeb3.Transaction().add(instruction);
                transaction.feePayer = wallet;
                
                const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
                transaction.recentBlockhash = blockhash;
                
                showLoading("Waiting for approval...", "Approve in Phantom");
                const signed = await walletProvider.signTransaction(transaction);
                
                showLoading("Sending transaction...");
                const signature = await connection.sendRawTransaction(signed.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: 'confirmed',
                    maxRetries: 3
                });
                
                showLoading("Confirming...");
                const confirmation = await connection.confirmTransaction({
                    signature: signature,
                    blockhash: blockhash,
                    lastValidBlockHeight: lastValidBlockHeight
                }, 'confirmed');
                
                if (confirmation.value.err) {
                    throw new Error('Transaction failed');
                }
                
                hideLoading();
                showToast(`${name}.carv registered! üéâ`, "success");
                
                document.getElementById("domainInput").value = "";
                document.getElementById("domainStatus").classList.add("hidden");
                document.getElementById("registerForm").classList.add("hidden");
                
                setTimeout(() => loadMyDomains(), 3000);
                
            } catch (e) {
                debugLog('ERROR register', e.message);
                hideLoading();
                showToast("Registration failed: " + e.message, "error");
            }
        }

        async function loadMyDomains() {
            if (!wallet || !connection) return;

            const container = document.getElementById("myDomains");
            container.innerHTML = '<div class="text-center py-4"><div class="w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full animate-spin mx-auto"></div></div>';

            try {
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                const accounts = await connection.getProgramAccounts(programId, {
                    filters: [{
                        memcmp: {
                            offset: 8,
                            bytes: wallet.toString(),
                        }
                    }]
                });

                if (accounts.length === 0) {
                    container.innerHTML = '<div class="text-gray-400 text-center py-12"><p>No domains yet</p></div>';
                    return;
                }

                const domains = accounts.map(account => {
                    const data = account.account.data;
                    try {
                        let offset = 40;
                        const nameLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                        offset += 4;
                        const nameBytes = data.slice(offset, offset + nameLen);
                        const name = new TextDecoder().decode(nameBytes);
                        offset += nameLen;
                        const registered = Number(new DataView(data.buffer, data.byteOffset + offset, 8).getBigInt64(0, true));
                        offset += 8;
                        const expires = Number(new DataView(data.buffer, data.byteOffset + offset, 8).getBigInt64(0, true));
                        offset += 8;
                        const active = data[offset] !== 0;
                        offset += 1;
                        const dataLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                        offset += 4;
                        const dataBytes = data.slice(offset, offset + dataLen);
                        const metadata = new TextDecoder().decode(dataBytes);
                        
                        return { address: account.pubkey.toString(), name, registered, expires, active, metadata };
                    } catch (e) {
                        return { address: account.pubkey.toString(), name: 'Unknown', registered: 0, expires: 0, active: false, metadata: '' };
                    }
                });

                const now = Math.floor(Date.now() / 1000);
                container.innerHTML = domains.map(domain => {
                    const daysLeft = Math.floor((domain.expires - now) / 86400);
                    const expired = daysLeft < 0;
                    const expiringSoon = daysLeft > 0 && daysLeft < 30;
                    
                    return `
                        <div class="bg-white/5 rounded-lg p-6 border border-white/10">
                            <div class="flex justify-between items-start mb-4">
                                <div>
                                    <h4 class="text-2xl font-bold mb-1">${domain.name}.carv</h4>
                                    <p class="text-sm text-gray-400">Expires: ${new Date(domain.expires * 1000).toLocaleDateString()}</p>
                                </div>
                                <span class="px-3 py-1 rounded-full text-sm font-semibold ${
                                    expired ? 'bg-red-500/20 text-red-300' : 
                                    expiringSoon ? 'bg-yellow-500/20 text-yellow-300' : 
                                    'bg-green-500/20 text-green-300'
                                }">
                                    ${expired ? '‚ö†Ô∏è Expired' : `‚úÖ ${daysLeft} days`}
                                </span>
                            </div>
                            ${domain.metadata ? `
                                <div class="mb-4 p-3 bg-white/5 rounded">
                                    <p class="text-xs text-gray-400 mb-1">Metadata:</p>
                                    <pre class="font-mono text-xs text-gray-300 overflow-x-auto">${domain.metadata}</pre>
                                </div>
                            ` : ''}
                            <div class="flex flex-wrap gap-2">
                                <button onclick="renewDomain('${domain.name}')" class="flex-1 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-semibold">
                                    üîÑ Renew
                                </button>
                                <button onclick="showTransferModal('${domain.name}')" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-semibold">
                                    ‚ÜîÔ∏è Transfer
                                </button>
                                <button onclick="showUpdateModal('${domain.name}', '${domain.address}')" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-semibold">
                                    ‚úèÔ∏è Update
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (e) {
                debugLog('ERROR loading domains', e.message);
                container.innerHTML = '<p class="text-red-400 text-center py-8">Error loading domains</p>';
            }
        }

        async function renewDomain(name) {
            try {
                if (!confirm(`Renew ${name}.carv for 0.02 SOL?`)) return;
                showLoading("Renewing...");
                
                const pda = await getDomainPDA(name);
                const treasury = new solanaWeb3.PublicKey(CONFIG.TREASURY_ADDRESS);
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                const discriminator = new Uint8Array([43, 239, 15, 46, 27, 7, 163, 73]);
                
                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: pda, isSigner: false, isWritable: true },
                        { pubkey: wallet, isSigner: true, isWritable: true },
                        { pubkey: treasury, isSigner: false, isWritable: true },
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                    ],
                    programId: programId,
                    data: discriminator,
                });
                
                const transaction = new solanaWeb3.Transaction().add(instruction);
                transaction.feePayer = wallet;
                const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
                transaction.recentBlockhash = blockhash;
                
                const signed = await walletProvider.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signed.serialize());
                await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
                
                hideLoading();
                showToast(`${name}.carv renewed! ‚ú®`, "success");
                setTimeout(() => loadMyDomains(), 2000);
            } catch (e) {
                debugLog('ERROR renew', e.message);
                hideLoading();
                showToast("Renew failed: " + e.message, "error");
            }
        }

        function showTransferModal(name) {
            const modal = document.createElement('div');
            modal.id = 'transferModal';
            modal.className = 'fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 max-w-md w-full mx-4">
                    <h3 class="text-2xl font-bold mb-4">Transfer ${name}.carv</h3>
                    <input type="text" id="transferAddress" placeholder="Recipient address" class="w-full px-4 py-3 bg-white/10 rounded-lg border border-white/20 mb-4"/>
                    <div class="flex gap-3">
                        <button onclick="closeTransferModal()" class="flex-1 px-4 py-3 bg-white/10 rounded-lg">Cancel</button>
                        <button onclick="transferDomain('${name}')" class="flex-1 px-4 py-3 bg-blue-600 rounded-lg">Transfer</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeTransferModal() {
            const modal = document.getElementById('transferModal');
            if (modal) modal.remove();
        }

        async function transferDomain(name) {
            try {
                const addressInput = document.getElementById('transferAddress').value.trim();
                if (!addressInput) {
                    showToast("Enter address", "error");
                    return;
                }
                
                closeTransferModal();
                showLoading("Transferring...");
                
                const pda = await getDomainPDA(name);
                const newOwner = new solanaWeb3.PublicKey(addressInput);
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                const discriminator = new Uint8Array([163, 52, 200, 231, 140, 3, 69, 186]);
                
                const data = new Uint8Array(discriminator.length + 32);
                data.set(discriminator, 0);
                data.set(newOwner.toBytes(), discriminator.length);
                
                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: pda, isSigner: false, isWritable: true },
                        { pubkey: wallet, isSigner: true, isWritable: false },
                    ],
                    programId: programId,
                    data: data,
                });
                
                const transaction = new solanaWeb3.Transaction().add(instruction);
                transaction.feePayer = wallet;
                const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
                transaction.recentBlockhash = blockhash;
                
                const signed = await walletProvider.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signed.serialize());
                await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
                
                hideLoading();
                showToast(`${name}.carv transferred! üéâ`, "success");
                setTimeout(() => loadMyDomains(), 2000);
            } catch (e) {
                debugLog('ERROR transfer', e.message);
                hideLoading();
                showToast("Transfer failed: " + e.message, "error");
            }
        }

        async function showUpdateModal(name, domainAddress) {
            let currentMetadata = '';
            try {
                const pda = new solanaWeb3.PublicKey(domainAddress);
                const accountInfo = await connection.getAccountInfo(pda);
                if (accountInfo) {
                    const data = accountInfo.data;
                    let offset = 40;
                    const nameLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                    offset += 4 + nameLen + 8 + 8 + 1;
                    const dataLen = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, true);
                    offset += 4;
                    const dataBytes = data.slice(offset, offset + dataLen);
                    currentMetadata = new TextDecoder().decode(dataBytes);
                }
            } catch (e) {}
            
            const modal = document.createElement('div');
            modal.id = 'updateModal';
            modal.className = 'fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20 max-w-md w-full mx-4">
                    <h3 class="text-2xl font-bold mb-4">Update ${name}.carv</h3>
                    <textarea id="updateMetadata" placeholder='{"twitter": "@handle"}' class="w-full px-4 py-3 bg-white/10 rounded-lg border border-white/20 mb-4 font-mono text-sm" rows="5">${currentMetadata}</textarea>
                    <div class="flex gap-3">
                        <button onclick="closeUpdateModal()" class="flex-1 px-4 py-3 bg-white/10 rounded-lg">Cancel</button>
                        <button onclick="updateMetadata('${name}')" class="flex-1 px-4 py-3 bg-green-600 rounded-lg">Update</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeUpdateModal() {
            const modal = document.getElementById('updateModal');
            if (modal) modal.remove();
        }

        async function updateMetadata(name) {
            try {
                const metadataInput = document.getElementById('updateMetadata').value.trim();
                if (metadataInput.length > 128) {
                    showToast("Max 128 chars", "error");
                    return;
                }
                
                closeUpdateModal();
                showLoading("Updating...");
                
                const pda = await getDomainPDA(name);
                const programId = new solanaWeb3.PublicKey(CONFIG.PROGRAM_ID);
                const discriminator = new Uint8Array([223, 114, 91, 136, 197, 78, 153, 153]);
                
                const metadataBytes = new TextEncoder().encode(metadataInput);
                const lengthBytes = new Uint8Array(4);
                new DataView(lengthBytes.buffer).setUint32(0, metadataBytes.length, true);
                
                const data = new Uint8Array(discriminator.length + lengthBytes.length + metadataBytes.length);
                let offset = 0;
                data.set(discriminator, offset);
                offset += discriminator.length;
                data.set(lengthBytes, offset);
                offset += lengthBytes.length;
                data.set(metadataBytes, offset);
                
                const instruction = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: pda, isSigner: false, isWritable: true },
                        { pubkey: wallet, isSigner: true, isWritable: false },
                    ],
                    programId: programId,
                    data: data,
                });
                
                const transaction = new solanaWeb3.Transaction().add(instruction);
                transaction.feePayer = wallet;
                const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
                transaction.recentBlockhash = blockhash;
                
                const signed = await walletProvider.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signed.serialize());
                await connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight }, 'confirmed');
                
                hideLoading();
                showToast(`${name}.carv updated! ‚ú®`, "success");
                setTimeout(() => loadMyDomains(), 2000);
            } catch (e) {
                debugLog('ERROR update', e.message);
                hideLoading();
                showToast("Update failed: " + e.message, "error");
            }
        }

        function toggleWalletMenu() {
            document.getElementById('walletMenu').classList.toggle('hidden');
        }

        function copyAddress() {
            navigator.clipboard.writeText(wallet.toString());
            showToast('Address copied! üìã', 'success');
        }

        async function disconnectWallet() {
            try {
                if (walletProvider && walletProvider.isConnected) {
                    await walletProvider.disconnect();
                }
                wallet = null;
                connection = null;
                walletProvider = null;
                
                const btn = document.getElementById("connectWallet");
                btn.innerHTML = "Connect Wallet";
                btn.classList.remove("bg-green-600");
                btn.classList.add("bg-purple-600");
                document.getElementById('walletMenu').classList.add('hidden');
                document.getElementById("myDomains").innerHTML = '<div class="text-gray-400 text-center py-12"><p>Connect wallet</p></div>';
                showToast('Disconnected', 'info');
                debugLog('Wallet disconnected');
            } catch (e) {
                debugLog('ERROR disconnect', e.message);
            }
        }

        function showSendSOLModalForSearch(domainName, ownerAddress) {
            document.getElementById('sendToDomain').textContent = domainName + '.carv';
            document.getElementById('sendToAddress').textContent = ownerAddress;
            document.getElementById('sendSOLModal').classList.remove('hidden');
            window.currentSendOwner = ownerAddress;
        }

        function closeSendSOLModal() {
            document.getElementById('sendSOLModal').classList.add('hidden');
            document.getElementById('solAmount').value = '';
        }

        async function sendSOL() {
            try {
                const amount = parseFloat(document.getElementById('solAmount').value);
                if (!amount || amount <= 0) {
                    showToast('Enter valid amount', 'error');
                    return;
                }
                
                const ownerAddress = window.currentSendOwner;
                if (!ownerAddress) {
                    showToast('Owner address not found', 'error');
                    return;
                }
                
                debugLog('Sending SOL', { amount, to: ownerAddress });
                showLoading('Sending SOL...', 'Please approve');
                
                const recipient = new solanaWeb3.PublicKey(ownerAddress);
                
                // Calculate lamports as plain number (works with Solana Web3.js)
                const lamports = amount * 1_000_000_000;
                
                debugLog('Transfer details', {
                    from: wallet.toString(),
                    to: recipient.toString(),
                    lamports: lamports,
                    lamportsType: typeof lamports
                });
                
                // Create transfer instruction manually to avoid encoding issues
                const transferIx = solanaWeb3.SystemProgram.transfer({
                    fromPubkey: wallet,
                    toPubkey: recipient,
                    lamports: lamports
                });
                
                debugLog('Transfer instruction created', {
                    programId: transferIx.programId.toString(),
                    keys: transferIx.keys.length
                });
                
                const transaction = new solanaWeb3.Transaction();
                transaction.add(transferIx);
                transaction.feePayer = wallet;
                
                const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
                transaction.recentBlockhash = blockhash;
                
                debugLog('Transaction prepared, requesting signature...');
                const signed = await window.solana.signTransaction(transaction);
                
                debugLog('Sending transaction...');
                const signature = await connection.sendRawTransaction(signed.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: 'confirmed'
                });
                
                debugLog('TX sent', { signature });
                showLoading('Confirming transaction...');
                
                const confirmation = await connection.confirmTransaction({
                    signature: signature,
                    blockhash: blockhash,
                    lastValidBlockHeight: lastValidBlockHeight
                }, 'confirmed');
                
                if (confirmation.value.err) {
                    throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
                }
                
                debugLog('TX confirmed successfully!');
                hideLoading();
                closeSendSOLModal();
                showToast(`${amount} SOL sent successfully! ‚úÖ`, 'success');
                
            } catch (e) {
                debugLog('ERROR sending SOL', e.message);
                console.error('Full error:', e);
                console.error('Error stack:', e.stack);
                hideLoading();
                
                let errorMsg = e.message;
                if (errorMsg.includes('User rejected')) {
                    errorMsg = 'Transaction cancelled';
                } else if (errorMsg.includes('insufficient')) {
                    errorMsg = 'Insufficient balance';
                } else if (errorMsg.includes('Blob.encode')) {
                    errorMsg = 'Transaction encoding error. Please try again.';
                }
                
                showToast('Failed to send SOL: ' + errorMsg, 'error');
            }
        }

        function showSendNFTModalForSearch(domainName, ownerAddress) {
            document.getElementById('sendNFTToDomain').textContent = domainName + '.carv';
            document.getElementById('sendNFTToAddress').textContent = ownerAddress;
            document.getElementById('sendNFTModal').classList.remove('hidden');
            window.currentNFTRecipient = ownerAddress;
        }

        function closeSendNFTModal() {
            document.getElementById('sendNFTModal').classList.add('hidden');
            document.getElementById('nftMintAddress').value = '';
        }

        async function sendNFT() {
            try {
                const mintAddress = document.getElementById('nftMintAddress').value.trim();
                if (!mintAddress) {
                    showToast('Enter NFT mint', 'error');
                    return;
                }
                
                const recipientAddress = window.currentNFTRecipient;
                if (!recipientAddress) {
                    showToast('Recipient not found', 'error');
                    return;
                }
                
                showLoading('Sending NFT...');
                
                const mint = new solanaWeb3.PublicKey(mintAddress);
                const recipient = new solanaWeb3.PublicKey(recipientAddress);
                const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
                const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
                
                async function findATA(walletAddr, tokenMint) {
                    const [address] = await solanaWeb3.PublicKey.findProgramAddress(
                        [walletAddr.toBytes(), TOKEN_PROGRAM_ID.toBytes(), tokenMint.toBytes()],
                        ASSOCIATED_TOKEN_PROGRAM_ID
                    );
                    return address;
                }
                
                const senderATA = await findATA(wallet, mint);
                const recipientATA = await findATA(recipient, mint);
                
                const recipientATAInfo = await connection.getAccountInfo(recipientATA);
                const transaction = new solanaWeb3.Transaction();
                
                if (!recipientATAInfo) {
                    const createATAIx = new solanaWeb3.TransactionInstruction({
                        keys: [
                            { pubkey: wallet, isSigner: true, isWritable: true },
                            { pubkey: recipientATA, isSigner: false, isWritable: true },
                            { pubkey: recipient, isSigner: false, isWritable: false },
                            { pubkey: mint, isSigner: false, isWritable: false },
                            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                            { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                        ],
                        programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                        data: Buffer.alloc(0)
                    });
                    transaction.add(createATAIx);
                }
                
                const transferData = new Uint8Array(9);
                transferData[0] = 3;
                transferData[1] = 1;
                
                const transferIx = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: senderATA, isSigner: false, isWritable: true },
                        { pubkey: recipientATA, isSigner: false, isWritable: true },
                        { pubkey: wallet, isSigner: true, isWritable: false },
                    ],
                    programId: TOKEN_PROGRAM_ID,
                    data: transferData
                });
                transaction.add(transferIx);
                
                transaction.feePayer = wallet;
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                
                const signed = await window.solana.signTransaction(transaction);
                const signature = await connection.sendRawTransaction(signed.serialize());
                await connection.confirmTransaction(signature);
                
                hideLoading();
                closeSendNFTModal();
                showToast('NFT sent! üéâ', 'success');
            } catch (e) {
                debugLog('ERROR sending NFT', e.message);
                hideLoading();
                showToast('Failed: ' + e.message, 'error');
            }
        }

        function updateUI() {
            const btn = document.getElementById("connectWallet");
            if (wallet) {
                btn.innerHTML = `<div class="flex items-center gap-2"><div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>${wallet.toString().slice(0, 4)}...${wallet.toString().slice(-4)}</div>`;
                btn.classList.add("bg-green-600");
                btn.classList.remove("bg-purple-600");
            }
        }

        function showLoading(text, sub = "") {
            document.getElementById("loadingText").textContent = text;
            document.getElementById("loadingSubtext").textContent = sub;
            document.getElementById("loadingOverlay").classList.remove("hidden");
        }

        function hideLoading() {
            document.getElementById("loadingOverlay").classList.add("hidden");
        }

        function showToast(msg, type = "info") {
            const toast = document.getElementById("toast");
            const icon = document.getElementById("toastIcon");
            const message = document.getElementById("toastMessage");
            const icons = {
                success: '<svg class="w-6 h-6 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>',
                error: '<svg class="w-6 h-6 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293z" clip-rule="evenodd"/></svg>',
                info: '<svg class="w-6 h-6 text-blue-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/></svg>'
            };
            icon.innerHTML = icons[type] || icons.info;
            message.innerHTML = msg;
            toast.classList.remove("hidden");
            setTimeout(() => toast.classList.add("hidden"), 5000);
        }

        document.getElementById("connectWallet").onclick = showWalletSelection;
        document.getElementById("searchBtn").onclick = searchDomain;
        document.getElementById("registerBtn").onclick = registerDomain;
        document.getElementById("toastClose").onclick = () => document.getElementById("toast").classList.add("hidden");
        document.getElementById("domainInput").onkeypress = (e) => { if (e.key === "Enter") searchDomain(); };
        document.getElementById("domainInput").oninput = (e) => { e.target.value = e.target.value.toLowerCase(); };

        window.addEventListener("load", () => {
            setTimeout(() => init(), 1000);
        });
    </script>

</body>
    </html>
